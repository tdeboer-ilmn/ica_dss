# coding: utf-8

"""
    Illumina Connected Analysis

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ica_client.api_client import ApiClient


class FoldersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def archive_folder(self, folder_id, body, **kwargs):  # noqa: E501
        """Archive a folder  # noqa: E501

        Archives a folder to a lower storage cost tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_folder(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be archived. (required)
        :param FolderArchiveRequest body:  (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.archive_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.archive_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
            return data

    def archive_folder_with_http_info(self, folder_id, body, **kwargs):  # noqa: E501
        """Archive a folder  # noqa: E501

        Archives a folder to a lower storage cost tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_folder_with_http_info(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be archived. (required)
        :param FolderArchiveRequest body:  (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `archive_folder`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `archive_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}:archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def complete_folder_session(self, folder_id, session_id, body, **kwargs):  # noqa: E501
        """Complete a folder upload in GDS  # noqa: E501

        Complete a folder upload in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_folder_session(folder_id, session_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the upload session. (required)
        :param str session_id: The id of the upload session (required)
        :param CompleteSessionRequest body: The request body (required)
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.complete_folder_session_with_http_info(folder_id, session_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.complete_folder_session_with_http_info(folder_id, session_id, body, **kwargs)  # noqa: E501
            return data

    def complete_folder_session_with_http_info(self, folder_id, session_id, body, **kwargs):  # noqa: E501
        """Complete a folder upload in GDS  # noqa: E501

        Complete a folder upload in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.complete_folder_session_with_http_info(folder_id, session_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the upload session. (required)
        :param str session_id: The id of the upload session (required)
        :param CompleteSessionRequest body: The request body (required)
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'session_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method complete_folder_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `complete_folder_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `complete_folder_session`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `complete_folder_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501
        if 'session_id' in params:
            path_params['sessionId'] = params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}/sessions/{sessionId}:complete', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_folder(self, folder_id, body, **kwargs):  # noqa: E501
        """Copy a folder  # noqa: E501

        Copy a folder into a target parent folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be copied. (required)
        :param FolderCopyRequest body:  (required)
        :param str tenant_id: Optional parameter to copy from a shared folder in another tenant
        :return: JobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
            return data

    def copy_folder_with_http_info(self, folder_id, body, **kwargs):  # noqa: E501
        """Copy a folder  # noqa: E501

        Copy a folder into a target parent folder  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_folder_with_http_info(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be copied. (required)
        :param FolderCopyRequest body:  (required)
        :param str tenant_id: Optional parameter to copy from a shared folder in another tenant
        :return: JobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'body', 'tenant_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `copy_folder`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []
        if 'tenant_id' in params:
            query_params.append(('tenantId', params['tenant_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}:copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_folder(self, body, **kwargs):  # noqa: E501
        """Create a folder in GDS and receive credentials for upload  # noqa: E501

        Create a folder entry in GDS. Returns temporary credentials for folder upload directly to S3 when the include=objectStoreAccess parameter is used. Volume ID or volume name is required for folder creation. If a folder path is provided and does not exist, GDS automatically creates the folder path in the appropriate account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateFolderRequest body:  (required)
        :param str include: Comma-separated list of properties to include in the response ([include=[totalItemCount]).Example: include=totalItemCount
        :return: FolderWriteableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_folder_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_folder_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_folder_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a folder in GDS and receive credentials for upload  # noqa: E501

        Create a folder entry in GDS. Returns temporary credentials for folder upload directly to S3 when the include=objectStoreAccess parameter is used. Volume ID or volume name is required for folder creation. If a folder path is provided and does not exist, GDS automatically creates the folder path in the appropriate account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_folder_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateFolderRequest body:  (required)
        :param str include: Comma-separated list of properties to include in the response ([include=[totalItemCount]).Example: include=totalItemCount
        :return: FolderWriteableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'include']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderWriteableResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_folder(self, folder_id, **kwargs):  # noqa: E501
        """Deletes a folder by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be deleted. (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def delete_folder_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Deletes a folder by id  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_folder_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be deleted. (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `delete_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder(self, folder_id, **kwargs):  # noqa: E501
        """Get information about a folder in GDS.  # noqa: E501

        Get information for the specified folder ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to retrieve. (required)
        :param str tenant_id: Optional parameter to see shared data in another tenant
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def get_folder_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Get information about a folder in GDS.  # noqa: E501

        Get information for the specified folder ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to retrieve. (required)
        :param str tenant_id: Optional parameter to see shared data in another tenant
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'tenant_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []
        if 'tenant_id' in params:
            query_params.append(('tenantId', params['tenant_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_job(self, folder_id, job_id, **kwargs):  # noqa: E501
        """Get status of a folder job in GDS  # noqa: E501

        Get status of a folder job in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_job(folder_id, job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the job. (required)
        :param str job_id: The id of the job (required)
        :return: JobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_job_with_http_info(folder_id, job_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_job_with_http_info(folder_id, job_id, **kwargs)  # noqa: E501
            return data

    def get_folder_job_with_http_info(self, folder_id, job_id, **kwargs):  # noqa: E501
        """Get status of a folder job in GDS  # noqa: E501

        Get status of a folder job in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_job_with_http_info(folder_id, job_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the job. (required)
        :param str job_id: The id of the job (required)
        :return: JobResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'job_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder_job`")  # noqa: E501
        # verify the required parameter 'job_id' is set
        if ('job_id' not in params or
                params['job_id'] is None):
            raise ValueError("Missing the required parameter `job_id` when calling `get_folder_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501
        if 'job_id' in params:
            path_params['jobId'] = params['job_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}/jobs/{jobId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='JobResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_folder_session(self, folder_id, session_id, **kwargs):  # noqa: E501
        """Get status of a folder upload in GDS  # noqa: E501

        Get status of a folder upload in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_session(folder_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the upload session. (required)
        :param str session_id: The id of the upload session (required)
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_folder_session_with_http_info(folder_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_folder_session_with_http_info(folder_id, session_id, **kwargs)  # noqa: E501
            return data

    def get_folder_session_with_http_info(self, folder_id, session_id, **kwargs):  # noqa: E501
        """Get status of a folder upload in GDS  # noqa: E501

        Get status of a folder upload in GDS.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_folder_session_with_http_info(folder_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder related to the upload session. (required)
        :param str session_id: The id of the upload session (required)
        :return: SessionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_folder_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `get_folder_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `get_folder_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501
        if 'session_id' in params:
            path_params['sessionId'] = params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}/sessions/{sessionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SessionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_folders(self, **kwargs):  # noqa: E501
        """Get a list of folders  # noqa: E501

        Given a volumeId or volume name, get a list of folders accessible by the JWT. The default sort returned is alphabetical, ascending. The default page size is 10 items  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] volume_id: Optional field that specifies comma-separated volume IDs to include in the list
        :param list[str] volume_name: Optional field that specifies comma-separated volume names to include in the list
        :param list[str] path: Optional field that specifies comma-separated paths to include in the list. Value can use wildcards (e.g. /a/b/c/*) or exact matches (e.g. /a/b/c/d/).
        :param str job_statuses: Optional field that specifies comma-separated JobStatuses to include in the list
        :param list[str] acls: Optional field that specifies comma-separated acls to include in the list
        :param bool recursive: Optional field to specify if folders should be returned recursively in and under the specified paths, or only directly in the specified paths
        :param int page_size: START_DESC END_DESC
        :param str page_token: START_DESC END_DESC
        :param str include: START_DESC END_DESC
        :param str tenant_id: Optional parameter to see shared data in another tenant
        :return: FolderListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_folders_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_folders_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_folders_with_http_info(self, **kwargs):  # noqa: E501
        """Get a list of folders  # noqa: E501

        Given a volumeId or volume name, get a list of folders accessible by the JWT. The default sort returned is alphabetical, ascending. The default page size is 10 items  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_folders_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] volume_id: Optional field that specifies comma-separated volume IDs to include in the list
        :param list[str] volume_name: Optional field that specifies comma-separated volume names to include in the list
        :param list[str] path: Optional field that specifies comma-separated paths to include in the list. Value can use wildcards (e.g. /a/b/c/*) or exact matches (e.g. /a/b/c/d/).
        :param str job_statuses: Optional field that specifies comma-separated JobStatuses to include in the list
        :param list[str] acls: Optional field that specifies comma-separated acls to include in the list
        :param bool recursive: Optional field to specify if folders should be returned recursively in and under the specified paths, or only directly in the specified paths
        :param int page_size: START_DESC END_DESC
        :param str page_token: START_DESC END_DESC
        :param str include: START_DESC END_DESC
        :param str tenant_id: Optional parameter to see shared data in another tenant
        :return: FolderListResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['volume_id', 'volume_name', 'path', 'job_statuses', 'acls', 'recursive', 'page_size', 'page_token', 'include', 'tenant_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_folders" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page_size' in params and params['page_size'] > 10000:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_folders`, must be a value less than or equal to `10000`")  # noqa: E501
        if 'page_size' in params and params['page_size'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `page_size` when calling `list_folders`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'volume_id' in params:
            query_params.append(('volume.id', params['volume_id']))  # noqa: E501
            collection_formats['volume.id'] = 'csv'  # noqa: E501
        if 'volume_name' in params:
            query_params.append(('volume.name', params['volume_name']))  # noqa: E501
            collection_formats['volume.name'] = 'csv'  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
            collection_formats['path'] = 'csv'  # noqa: E501
        if 'job_statuses' in params:
            query_params.append(('jobStatuses', params['job_statuses']))  # noqa: E501
        if 'acls' in params:
            query_params.append(('acls', params['acls']))  # noqa: E501
            collection_formats['acls'] = 'csv'  # noqa: E501
        if 'recursive' in params:
            query_params.append(('recursive', params['recursive']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'page_token' in params:
            query_params.append(('pageToken', params['page_token']))  # noqa: E501
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501
        if 'tenant_id' in params:
            query_params.append(('tenantId', params['tenant_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderListResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unarchive_folder(self, folder_id, body, **kwargs):  # noqa: E501
        """Unarchive a folder  # noqa: E501

        Unarchive a folder from a lower storage cost tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unarchive_folder(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be unarchived. (required)
        :param FolderUnarchiveRequest body:  (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unarchive_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.unarchive_folder_with_http_info(folder_id, body, **kwargs)  # noqa: E501
            return data

    def unarchive_folder_with_http_info(self, folder_id, body, **kwargs):  # noqa: E501
        """Unarchive a folder  # noqa: E501

        Unarchive a folder from a lower storage cost tier.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unarchive_folder_with_http_info(folder_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be unarchived. (required)
        :param FolderUnarchiveRequest body:  (required)
        :return: FolderResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unarchive_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `unarchive_folder`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `unarchive_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}:unarchive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_folder(self, folder_id, **kwargs):  # noqa: E501
        """Update a folder content or acl  # noqa: E501

        Update an existing folder in GDS and return upload credentials for that folder. Changes to the folder name and other metadata are not supported at this time.  Optionally overwrite the acl for this folder if acl is provided in the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be updated. (required)
        :param str include: Comma-separated list of properties to include in the response ([include=[totalItemCount]).Example: include=totalItemCount
        :param FolderUpdateRequest body: 
        :return: FolderWriteableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_folder_with_http_info(folder_id, **kwargs)  # noqa: E501
            return data

    def update_folder_with_http_info(self, folder_id, **kwargs):  # noqa: E501
        """Update a folder content or acl  # noqa: E501

        Update an existing folder in GDS and return upload credentials for that folder. Changes to the folder name and other metadata are not supported at this time.  Optionally overwrite the acl for this folder if acl is provided in the request.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_folder_with_http_info(folder_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str folder_id: Unique identifier for the folder to be updated. (required)
        :param str include: Comma-separated list of properties to include in the response ([include=[totalItemCount]).Example: include=totalItemCount
        :param FolderUpdateRequest body: 
        :return: FolderWriteableResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['folder_id', 'include', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_folder" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'folder_id' is set
        if ('folder_id' not in params or
                params['folder_id'] is None):
            raise ValueError("Missing the required parameter `folder_id` when calling `update_folder`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'folder_id' in params:
            path_params['folderId'] = params['folder_id']  # noqa: E501

        query_params = []
        if 'include' in params:
            query_params.append(('include', params['include']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json-patch+json', 'application/json', 'text/json', 'application/*+json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Basic', 'Bearer']  # noqa: E501

        return self.api_client.call_api(
            '/v1/folders/{folderId}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='FolderWriteableResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
